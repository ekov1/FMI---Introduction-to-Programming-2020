// На всеки етап може да иползвате функциите, който вече сте имплементирали.

1. Напишете функция Create10, която създава масив с 10 рационални числа.
2. Напишете функция CreateN, която създава масив с N рационални числа.
3. Напишете функция DemoCreate, която ползва Create10 и CreateN по подходящ начин

4. Напишете функция Initialize15, която приема масив с 15 елемента и го инициализар с 0.
5. Напишете функция Initialize11_42, която приема масив с 11 елемента и го инициализар с 42.42 .
6  Напишете функция InitializeN, която приема масив с N елемента и го инициализира с 0.
7. Напишете функция InitializeN_X, която приема масив с N елемента и го инициализира с стойност подадена като аргумент.
8. Напишете функция InitializeN_F, която приема масив с N елемента и го инициализира с помоща на подадена функция от вид `float f(int index)`,
която приема индекс и връща стойност с която трябва да бъде инициализарн елемент на този индекс.
9. Напишете функция DemoInitialize, която ползва всички InitializeXXX фунцкии по подходящ начин.


10. Напишете функция Print10, която приема масив с 10 елемента и отпечатва елементите на стандарният изход.
11. Напишете функция PrintN, която приема масив с 10 елемента и отпечатва елементите на стандарният изход.
12. Напишете функция DemoPrint, която ползва всички PrintXXX функции по подходящ начин.

13. Напишете функция Read10, която чете 10 рационални числа от стандартният вход и ги записва в подаден масив.
14. Напишете функция ReadN, която чете N рационални числа от стандартният вход и ги записва в подаден масив.
15. Напишете функция DemoRead, която ползва всички ReadXXX фунцкии по подходящ начин.

16. Напишете фунцкия Max3, която прима 3 рационални числа и извежда максималното от тях.
17. Напишете функция MaxN, която приема масив с N рационални числа и извежда максималното от тях.
18. Напишете функция MinN, която приема масив с N рационални числа и извежда минималното от тях.
19. Напишете функция MaxN_F, която приема масив с N рационални числа и функция от вида `bool comparator(float a, float b)`, MaxN_F трябва да връща максималният елемент срямо `comparator`.
20. Напишете функция MinN_F, която приема масив с N рационални числа и функция от вида `bool comparator(float a, float b)`, MaxN_F трябва да връща минималният елемент срямо `comparator`.
21. Напишете функция DemoМinMax, която ползва всички MinXXX и MaxXXX фунцкии по подходящ начин.

22. Напишете функция Find3, която приема масив от N рационални числа и връща индексът на елемент със стойност `3` (ако има повече от 1 връща първото).
23. Напишете функция FindN, която приема масив от N рационални числа и още 1 рационално число `X`, функцията трябва да върне индексът на X масивa (ако има повече от 1 връща първото).
24. Напишете функция DemoFind, която ползва всички FindXXX фунцкии по подходящ начин.

25. Напишете функция FilterNotX, която получава масив от N рационални числа и още 1 рационално число `X`, функцията трябва да върне нов масив с всички елементи разлини от 'X'.
26. Напишете функция FilterLessX, която получава масив от N рационални числа и още 1 рационално число `X`, функцията трябва да върне нов масив с всички елементи по-малки от 'X'.
27. Напишете функция FilterGreaterX, която получава масив от N рационални числа и още 1 рационално число `X`, функцията трябва да върне нов масив с всички елементи по-големи от 'X'.
28, Напишете функция Filter, която получава масив от N рационални числа и функция `bool isOk(int index, float value)`, фунцкията трябва да върне нов масив с всички елементи за който isOk
връща `true`
29. Напишете функция DemoFilter, която ползва всички FilterXXX фунцкии по подходящ начин.

30. Напишете функция AddToArray, която получава масив от N рационални числа и още 1 рационално число `X`, фунцкията трябва да върне нов масив с N + 1 числа, който съдържа всички
елемент от входния масив и 'x'.
31. Напишете функция RemoveFromArray, която получава масив от N рационални числа и цяло число 'index', фунцкията трябва да върне нов масив с N - 1 числа, който съдържа всички
елемент от входния масив без елемента на позиция `index`.
32. Напишете функция Merge, която получава масив от N рационални числа и масив от M рационални числа, фунцкията трябва да върне нов масив с N + М числа, който съдържа всички
елемент от входните масиви.
33. Напишете функция Splice, която получава масив от N рационални числа, цяло число `start` и цяло число `count`, фунцкията трябва да върне нов масив с елементите който започват на
индекс `start` и завършват на индекс `start + count` (предвидете крайните случай).
34. Напишете функция Reverse, която приема масив с N елемента и връща нов масив с елементите на входният записани в обратен ред.
35. Напишете функция ReverseInplace, която приема масив с N елемента и обръща елементите в него в обратен ред.
36. Напишете функция DemoArrayOperation, която ползва AddToArray, Merge, Splice, Reverse, ReverseInplace по походящ начин.

37. Напишете функция MapPower2, която получава масив от N рационални числа, и връща нов масив който съдържа числата от входния масив повдихнати на квадрат.
38. Напишете функция MapPower3, която получава масив от N рационални числа, и връща нов масив който съдържа числата от входния масив повдихнати на куб.
39. Напишете функция MapMax, която получава масив от N рационални числа, и връща нов масив който съдържа елементите от входният масив, но от всеки е изваден максималният елемент в масива.
40. Напишете функция MapPlusIndex, която получава масив от N рационални числа, и връща нов масив който съдържа елементите от входният масив, но към всеки елемент е прибавен индексът му в масива.
41. Напишете функция Map, която получава масив от N рационални числа `float Transform(float x, int index)`, връща масив който съдържа елементите от оригиналният масив следкато към тях е приложена `Transform`.
42. Напишете функция DemoMap, която ползва MapXXX по походящ начин.

43. Напишете функция SumArray, която получа масив от N рационални числа и връща тяхната сума.
44. Напишете функция MultArray, която получа масив от N рационални числа и връща тяхното произведение.
45. Напишете функция Accumulate, която получава масив от N рационални числа, рационално число `start`, и функция от вида  float reducer(float accumulator, float value),
функцията reducer трябва да се изпълни за всеки елемент от масива. За първия елемен стойноста на `accumulator` трябва да е 'start' за всяка следваща итерация `accumulator` трябва да
да бъде резултатът от предното изпълнение на `reducer`, стойноста на `value` трябва да е i-тия елемент от масива. Accumulate трябва да върне последната стойност която е върнал `reducer`.
46. Напишете функция SumArrayAccumulate, която прави същото като SumArray, но използва Accumulate.
47. Напишете функция MultArrayAccumulate, която прави същото като MultArray, но използва Accumulate.
48. Напишете фунцкия Count4, която получава масив от N рационални числа, функцията колко пъти се среща числото `4`. Имплементацията трябва да използва Accumulate.
49. Напишете фунцкия NumberInInterval, която получава масив от N рационални числа и рационални числа a и б  , трябва да върне броят на числата в [a,b] използвайки Accumulate за имплементацията.
50. Напишете фунцкия DemoAccumulate, която показва употрябвата на Accumulate по подходящ начин.

51. Имплементирайте RecursiveInitializeN, която прави същото като InitializeN, но е имплементирана рекурсивно.
52. Имплементирайте RecursivePrintN, която прави същото като PrintN, но е имплементирана рекурсивно.
53. Имплементирайте RecursiveFindN, която прави същото като FindN, но е имплементирана рекурсивно.
54. Имплементирайте RecursiveFilter, която прави същото като Filter, но е имплементирана рекурсивно.
55. Имплементирайте RecursiveMap, която прави същото като Map, но е имплементирана рекурсивно.
56. Имплементирайте RecursiveAccumulate, която прави същото като Accumulate, но е имплементирана рекурсивно.
